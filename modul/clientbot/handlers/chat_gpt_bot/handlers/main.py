import html
import logging
import random
import os
import time
from asgiref.sync import sync_to_async
from aiogram import Bot, Dispatcher, types
from aiogram import F
from aiogram.filters import Command, CommandStart, StateFilter
from aiogram.types import FSInputFile, Message, CallbackQuery
from aiogram.utils.deep_linking import create_start_link
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.fsm.context import FSMContext
import asyncio

from modul.clientbot import shortcuts
from modul.clientbot.handlers.admin.keyboards import main_menu_bt
from modul.clientbot.handlers.chat_gpt_bot import buttons as bt
from modul.clientbot.handlers.chat_gpt_bot.all_openai import ChatGPT
from modul.clientbot.handlers.refs.handlers.bot import banned, check_channels
from modul.clientbot.handlers.refs.shortcuts import get_actual_price
# from modul.clientbot.handlers.main import save_user
from modul.loader import client_bot_router
from modul.clientbot.handlers.chat_gpt_bot.states import AiState, AiAdminState, ChatGptFilter
from modul.clientbot.handlers.chat_gpt_bot.shortcuts import (get_all_names, get_all_ids,
                                                             get_info_db, get_user_balance_db,
                                                             default_checker, update_bc,
                                                             update_bc_name, get_channels_with_type_for_check,
                                                             remove_sponsor_channel, process_chatgpt_referral_bonus)

robot = ChatGPT()

logger = logging.getLogger(__name__)

# ==========================================
# STAR NARXLARI KONSTANTASI
# ==========================================
STAR_PRICES = {
    'gpt3_no_context': 1,
    'gpt3_context': 2,
    'gpt4_no_context': 3,
    'gpt4_context': 4
}


def chat_gpt_bot_handlers():
    @client_bot_router.message(lambda message: message.text == "/adminpayamount")
    async def adminpayamount_cmd(message: types.Message, state: FSMContext):
        print("sad")
        await message.answer('–ü—Ä–∏—à–ª–∏ —Ç–æ–∫–µ–Ω')
        await state.set_state(AiAdminState.check_token_and_update)


from modul.clientbot.handlers.chat_gpt_bot.all_openai import ChatGPT

chatgpt = ChatGPT()


@client_bot_router.message(AiAdminState.check_token_and_update)
async def check_token_and_update(message: types.Message, state: FSMContext):
    if message.text == 'da98s74d5qw89a4dw6854a':
        await message.answer('–í–ø–∏—à–∏—Ç–µ id –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –∏–ª–∏ –≤—ã–±–µ—Ä–∏ –µ–≥–æ –∏–∑ –∫–Ω–æ–ø–æ–∫',
                             reply_markup=bt.get_all_user_bt())
        await state.set_state(AiAdminState.check_user_to_update)
    else:
        await message.answer('Error')


@client_bot_router.message(AiAdminState.check_user_to_update)
async def check_user_to_update(message: types.Message, state: FSMContext):
    people = [str(i).strip("(),'") for i in await get_all_names()]
    ids = [str(i).strip("(),'") for i in await get_all_ids()]

    if message.text in people:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –¥–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è", reply_markup=types.ReplyKeyboardRemove())
        await state.set_state(AiAdminState.update_balance_state)
        await state.set_data(message.from_user.id, {"username": message.text})
    elif message.text in ids:
        await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –¥–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è", reply_markup=types.ReplyKeyboardRemove())
        await state.set_state(AiAdminState.update_balance_state)
        await state.set_data(message.from_user.id, {"username": message.text})
    else:
        await message.answer("Error Find Buttons", reply_markup=types.ReplyKeyboardRemove())


@client_bot_router.message(AiAdminState.update_balance_state)
async def update_balance(message: types.Message, state: FSMContext):
    data = await state.get_data(message.from_user.id)
    if message.text:
        amount = message.text
        if "userid" in data:
            await update_bc(tg_id=data["userid"], sign='+', amount=amount)
        elif "username" in data:
            await update_bc_name(tg_id=data["username"], sign='+', amount=amount)
        await message.answer('Successfully updated')
    else:
        await message.answer('Error updating')


@client_bot_router.message(
    StateFilter(None),
    ChatGptFilter()
)
async def start_message(message: types.Message, state: FSMContext, bot: Bot):
    from modul.clientbot.handlers.main import save_user
    user_id = message.from_user.id

    if message.text == "/adminpayamount":
        await message.answer('–ü—Ä–∏—à–ª–∏ —Ç–æ–∫–µ–Ω')
        await state.set_state(AiAdminState.check_token_and_update)
        print(await state.get_state())
        return

    print(await state.get_state())

    referral = None
    if message.text and message.text.startswith('/start '):
        args = message.text[7:]
        if args and args.isdigit():
            referral = args
            await state.update_data(referral=referral)
            print(f"Extracted referral: {referral}")

    channels = await get_channels_with_type_for_check()
    print(f"üì° Found channels: {channels}")

    if channels:
        print(f"üîí Channels exist, checking user subscription for {user_id}")
        not_subscribed_channels = []
        invalid_channels_to_remove = []

        for channel_id, channel_url, channel_type in channels:
            try:
                if channel_type == 'system':
                    from modul.loader import main_bot
                    member = await main_bot.get_chat_member(chat_id=int(channel_id), user_id=user_id)
                    print(f"System channel {channel_id} checked via main_bot: {member.status}")
                else:
                    member = await message.bot.get_chat_member(chat_id=int(channel_id), user_id=user_id)
                    print(f"Sponsor channel {channel_id} checked via current_bot: {member.status}")

                if member.status == "left":
                    try:
                        if channel_type == 'system':
                            chat_info = await main_bot.get_chat(chat_id=int(channel_id))
                        else:
                            chat_info = await message.bot.get_chat(chat_id=int(channel_id))

                        not_subscribed_channels.append({
                            'id': channel_id,
                            'title': chat_info.title,
                            'invite_link': channel_url or chat_info.invite_link or f"https://t.me/{channel_id.strip('-')}"
                        })
                    except Exception as e:
                        print(f"‚ö†Ô∏è Error getting chat info for channel {channel_id}: {e}")
                        not_subscribed_channels.append({
                            'id': channel_id,
                            'title': f"–ö–∞–Ω–∞–ª {channel_id}",
                            'invite_link': channel_url or f"https://t.me/{channel_id.strip('-')}"
                        })
            except Exception as e:
                logger.error(f"Error checking channel {channel_id} (type: {channel_type}): {e}")

                if channel_type == 'sponsor':
                    invalid_channels_to_remove.append(channel_id)
                    logger.info(f"Added invalid sponsor channel {channel_id} to removal list")
                else:
                    logger.warning(f"System channel {channel_id} error (ignoring): {e}")
                continue

        if invalid_channels_to_remove:
            for channel_id in invalid_channels_to_remove:
                await remove_sponsor_channel(channel_id)

        if not_subscribed_channels:
            print(f"üö´ User {user_id} not subscribed to all channels")

            channels_text = "üì¢ <b>–î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –∫–∞–Ω–∞–ª—ã:</b>\n\n"
            kb = InlineKeyboardBuilder()

            for index, channel in enumerate(not_subscribed_channels):
                title = channel['title']
                invite_link = channel['invite_link']

                channels_text += f"{index + 1}. {title}\n"
                kb.button(text=f"üì¢ {title}", url=invite_link)

            kb.button(text="‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="check_chan_chatgpt")
            kb.adjust(1)

            await message.answer(
                channels_text + "\n\n–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É ¬´–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É¬ª.",
                reply_markup=kb.as_markup(),
                parse_mode="HTML"
            )

            print(f"üìù State saved for user {user_id}: referral data will be processed after channel check")
            return

    print(f"‚úÖ User {user_id} subscribed to all channels or no channels found")
    try:
        bot_db_id = await get_chatgpt_bot_db_id(message.bot.token)
        result = await get_user_balance_db(user_id, bot_db_id)
        print(f"User {user_id} found in database: {result}")
        await message.answer(
            f'–ü—Ä–∏–≤–µ—Ç {message.from_user.username}\n–í–∞—à –±–∞–ª–∞–Ω—Å - {result:.0f} ‚≠êÔ∏è',
            reply_markup=bt.first_buttons()
        )
    except:
        print(f"User {user_id} not found, creating new user")
        new_link = await create_start_link(message.bot, str(message.from_user.id), encode=True)
        link_for_db = new_link[new_link.index("=") + 1:]
        try:
            await save_user(u=message.from_user, bot=bot, link=link_for_db, referrer_id=referral)
        except TypeError:
            await save_user(u=message.from_user, bot=bot, link=link_for_db)

        if referral and referral.isdigit():
            ref_id = int(referral)
            if ref_id != user_id:
                print(f"üîÑ Processing referral for NEW user {user_id} from {ref_id}")
                success, reward = await process_chatgpt_referral_bonus(user_id, ref_id, bot.token)

                if success:
                    try:
                        user_name = html.escape(message.from_user.first_name)
                        user_profile_link = f'tg://user?id={user_id}'

                        await asyncio.sleep(1)

                        await bot.send_message(
                            chat_id=ref_id,
                            text=f"–£ –≤–∞—Å –Ω–æ–≤—ã–π —Ä–µ—Ñ–µ—Ä–∞–ª! <a href='{user_profile_link}'>{user_name}</a>\n"
                                 f"üí∞ –ü–æ–ª—É—á–µ–Ω–æ: {reward} ‚≠êÔ∏è",
                            parse_mode="HTML"
                        )
                        print(f"üì® Sent referral notification to {ref_id} about user {user_id}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è Error sending notification to referrer {ref_id}: {e}")

        result = await get_user_balance_db(user_id, bot.token)
        print(f"New user {user_id} created: {result}")

        await message.answer(
            f'–ü—Ä–∏–≤–µ—Ç {message.from_user.username}\n–í–∞—à –±–∞–ª–∞–Ω—Å - {result:.0f} ‚≠êÔ∏è',
            reply_markup=bt.first_buttons()
        )

    await state.clear()


@client_bot_router.callback_query(F.data == "check_chan_chatgpt", ChatGptFilter())
async def check_channels_chatgpt_callback(callback: CallbackQuery, state: FSMContext, bot: Bot):
    """ChatGPT bot uchun kanal obunasini tekshirish"""
    from modul.clientbot.handlers.main import save_user
    user_id = callback.from_user.id
    print(f"üîç ChatGPT check_chan callback triggered for user {user_id}")

    # State dan referral ma'lumotni olish
    state_data = await state.get_data()
    referral = state_data.get('referral')
    print(f"üë§ Referral from state for user {user_id}: {referral}")

    # Kanallarni qayta tekshirish
    channels = await get_channels_with_type_for_check()

    subscribed_all = True
    invalid_channels_to_remove = []

    for channel_id, channel_url, channel_type in channels:
        try:
            if channel_type == 'system':
                from modul.loader import main_bot
                member = await main_bot.get_chat_member(chat_id=int(channel_id), user_id=user_id)
            else:
                member = await bot.get_chat_member(chat_id=int(channel_id), user_id=user_id)

            if member.status in ['left', 'kicked']:
                subscribed_all = False
                break
        except Exception as e:
            logger.error(f"Error checking channel {channel_id} (type: {channel_type}): {e}")
            if channel_type == 'sponsor':
                invalid_channels_to_remove.append(channel_id)
            subscribed_all = False
            break

    if invalid_channels_to_remove:
        for channel_id in invalid_channels_to_remove:
            await remove_sponsor_channel(channel_id)

    if not subscribed_all:
        await callback.answer("‚ùå –í—ã –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–ª–∏—Å—å –Ω–∞ –≤—Å–µ –∫–∞–Ω–∞–ª—ã!", show_alert=True)
        return

    print(f"‚úÖ User {user_id} subscribed to all channels")

    try:
        result = await get_info_db(user_id)
        print(f"User {user_id} already exists")
    except:
        print(f"Creating new user {user_id}")
        new_link = await create_start_link(bot, str(user_id), encode=True)
        link_for_db = new_link[new_link.index("=") + 1:]
        await save_user(u=callback.from_user, bot=bot, link=link_for_db, referrer_id=referral)
        if referral and referral.isdigit():
            ref_id = int(referral)
            if ref_id != user_id:
                success, reward = await process_chatgpt_referral_bonus(user_id, ref_id, bot.token)

                if success:
                    try:
                        user_name = html.escape(callback.from_user.first_name)
                        user_profile_link = f'tg://user?id={user_id}'

                        await bot.send_message(
                            chat_id=ref_id,
                            text=f"–£ –≤–∞—Å –Ω–æ–≤—ã–π —Ä–µ—Ñ–µ—Ä–∞–ª! <a href='{user_profile_link}'>{user_name}</a>\n"
                                 f"üí∞ –ü–æ–ª—É—á–µ–Ω–æ: {reward}‚ÇΩ",
                            parse_mode="HTML"
                        )
                    except Exception as e:
                        print(f"Error sending referral notification: {e}")

    try:
        await callback.message.delete()
    except:
        pass

    result = await get_user_balance_db(user_id, bot.token)
    await callback.message.answer(
        f'–ü—Ä–∏–≤–µ—Ç {callback.from_user.username}\n–í–∞—à –±–∞–ª–∞–Ω—Å - {result:.0f}',
        reply_markup=bt.first_buttons()
    )

    await state.clear()
    await callback.answer()


@client_bot_router.message(StateFilter('waiting_for_gpt4'), ChatGptFilter())
async def test_gpt4_handler(message: Message, state: FSMContext):
    """Vaqtincha test handler"""
    print(f"üü¢ GPT-4 handler triggered!")
    print(f"   Message: {message.text}")

    await message.answer("‚úÖ Test: GPT-4 handler ishlayapti!")
    await state.clear()
    print(f"   State cleared!")


@client_bot_router.callback_query(F.data == "chat_4")
async def chat_4_callback(callback_query: types.CallbackQuery):
    await callback_query.message.edit_text(
        'ü§ñ GPT-4:\n\n'
        'üìã –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å–∞–º–∞—è –ø–æ—Å–ª–µ–¥–Ω—è—è —è–∑—ã–∫–æ–≤–∞—è –º–æ–¥–µ–ª—å GPT-4 Turbo.\n'
        'üîò –ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–µ–∫—Å—Ç.\n'
        'üóØ –ß–∞—Ç –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ ‚Äî –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç, –∫–∞–∂–¥—ã–π –≤–∞—à –∑–∞–ø—Ä–æ—Å –∫–∞–∫ –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥.\n'
        '‚ö°Ô∏è 1 –∑–∞–ø—Ä–æ—Å = 3 ‚≠êÔ∏è\n'
        'üí¨ –ß–∞—Ç —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º ‚Äî –∫–∞–∂–¥—ã–π –æ—Ç–≤–µ—Ç —Å —É—á–µ—Ç–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –≤–∞—à–µ–≥–æ –¥–∏–∞–ª–æ–≥–∞.\n'
        '‚ö°Ô∏è 1 –∑–∞–ø—Ä–æ—Å = 4 ‚≠êÔ∏è\n'
        '‚îî –í—ã–±–µ—Ä–∏—Ç–µ —á–∞—Ç:',
        reply_markup=bt.choice_1_4()
    )


@client_bot_router.callback_query(F.data == "chat_3")
async def chat_3_callback(callback: types.CallbackQuery):
    await callback.message.edit_text(
        'ü§ñ GPT-3.5:\n\n'
        'üìã –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å–∞–º–∞—è —ç–∫–æ–Ω–æ–º–∏—á–µ—Å–∫–∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –º–æ–¥–µ–ª—å GPT-3.5 Turbo.\n'
        'üîò –ü—Ä–∏–Ω–∏–º–∞–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ.\n'
        'üóØ –ß–∞—Ç –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ ‚Äî –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç, –∫–∞–∂–¥—ã–π –≤–∞—à –∑–∞–ø—Ä–æ—Å –∫–∞–∫ –Ω–æ–≤—ã–π –¥–∏–∞–ª–æ–≥.\n'
        '‚ö°Ô∏è 1 –∑–∞–ø—Ä–æ—Å = 1 ‚≠êÔ∏è\n'
        'üí¨ –ß–∞—Ç —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º ‚Äî –∫–∞–∂–¥—ã–π –æ—Ç–≤–µ—Ç —Å —É—á–µ—Ç–æ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –≤–∞—à–µ–≥–æ –¥–∏–∞–ª–æ–≥–∞.\n'
        '‚ö°Ô∏è 1 –∑–∞–ø—Ä–æ—Å = 2 ‚≠êÔ∏è',
        reply_markup=bt.choice_1_3_5()
    )


# ==========================================
# UTILITY FUNCTIONS
# ==========================================

@sync_to_async
def get_chatgpt_bot_db_id(bot_identifier):
    """
    Bot identifikatoridan database ID ni olish (flexible)
    bot_identifier - Bot database ID yoki Bot token
    Returns: Database ID (int) yoki None
    """
    try:
        from modul.models import Bot

        # Agar int bo'lsa, avval database ID deb tekshiramiz
        if isinstance(bot_identifier, int):
            bot = Bot.objects.filter(id=bot_identifier).first()
            if bot:
                logger.info(f"‚úÖ Bot found by ID: {bot.id}, username={bot.username}")
                return bot.id

        # Token deb tekshiramiz
        bot = Bot.objects.filter(token=str(bot_identifier)).first()

        if bot:
            logger.info(f"‚úÖ Bot found by token: ID={bot.id}, username={bot.username}")
            return bot.id
        else:
            logger.error(f"‚ùå Bot not found with identifier: {str(bot_identifier)[:15]}...")
            return None

    except Exception as e:
        logger.error(f"‚ùå Error getting bot DB ID: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return None


@sync_to_async
def get_user_balance_db(user_id: int, bot_identifier):
    """
    Foydalanuvchining balansini hisoblash (Flexible - ID yoki Token)
    user_id - foydalanuvchi Telegram ID si
    bot_identifier - Bot database ID yoki Bot token
    Returns: Balance in Stars (float)
    """
    try:
        from modul.models import PaymentTransaction, Bot
        from django.db.models import Sum

        actual_bot_id = None

        # 1. Avval database ID deb tekshiramiz
        if isinstance(bot_identifier, int):
            logger.info(f"üîç Trying as database ID: {bot_identifier}")

            bot_exists = Bot.objects.filter(id=bot_identifier).exists()

            if bot_exists:
                logger.info(f"‚úÖ Bot exists with ID: {bot_identifier}")
                total = PaymentTransaction.objects.filter(
                    user_id=user_id,
                    bot_id=bot_identifier,
                    status='completed'
                ).aggregate(total_stars=Sum('amount_stars'))

                balance = float(total['total_stars']) if total['total_stars'] else 0.0
                logger.info(
                    f"‚úÖ Balance by database ID: user={user_id}, bot_id={bot_identifier}, balance={balance:.0f} ‚≠êÔ∏è")
                return balance
            else:
                logger.info(f"‚ö†Ô∏è Bot not found by ID {bot_identifier}, trying as token...")

        # 2. Token deb tekshiramiz
        logger.info(f"üîç Looking up bot by token: {str(bot_identifier)[:15]}...")

        bot = Bot.objects.filter(token=str(bot_identifier)).first()

        if bot:
            logger.info(f"‚úÖ Bot found by token: database ID={bot.id}")
            actual_bot_id = bot.id

            total = PaymentTransaction.objects.filter(
                user_id=user_id,
                bot_id=actual_bot_id,
                status='completed'
            ).aggregate(total_stars=Sum('amount_stars'))

            balance = float(total['total_stars']) if total['total_stars'] else 0.0
            logger.info(f"‚úÖ Balance for user {user_id} in bot {actual_bot_id} (via token): {balance:.0f} ‚≠êÔ∏è")
            return balance
        else:
            logger.warning(f"‚ö†Ô∏è Bot not found by token: {str(bot_identifier)[:15]}...")
            logger.error(f"‚ùå Bot not found with identifier: {bot_identifier}")
            return 0.0

    except Exception as e:
        logger.error(f"‚ùå Error getting balance for user {user_id}: {e}")
        import traceback
        logger.error(traceback.format_exc())
        return 0.0


# ==========================================
# GPT CHAT HANDLERS - YANGILANGAN
# ==========================================

@client_bot_router.callback_query(F.data.in_(['not', 'with', 'not4', 'with4', 'again_gpt3', 'again_gpt4']))
async def chat_options_callback(callback: types.CallbackQuery, state: FSMContext):
    """GPT tanlov - balance checking bilan"""
    user_id = callback.from_user.id

    bot_db_id = await get_chatgpt_bot_db_id(callback.bot.token)

    if not bot_db_id:
        await callback.answer("‚ùå –û—à–∏–±–∫–∞: –±–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    user_balance = await get_user_balance_db(user_id, bot_db_id)

    # Narxlar - Stars da
    prices = {
        'not': STAR_PRICES['gpt3_no_context'],
        'again_gpt3': STAR_PRICES['gpt3_no_context'],
        'with': STAR_PRICES['gpt3_context'],
        'not4': STAR_PRICES['gpt4_no_context'],
        'again_gpt4': STAR_PRICES['gpt4_no_context'],
        'with4': STAR_PRICES['gpt4_context']
    }

    price = prices.get(callback.data, 1)

    # BALANS TEKSHIRISH - ESKI KODDA BU YO'Q EDI!
    if user_balance < price:
        await callback.message.answer(
            f'‚ö†Ô∏è <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!</b>\n\n'
            f'üí∞ –í–∞—à –±–∞–ª–∞–Ω—Å: {user_balance:.0f} ‚≠êÔ∏è\n'
            f'üí≥ –¢—Ä–µ–±—É–µ—Ç—Å—è: {price} ‚≠êÔ∏è\n'
            f'üìä –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç: {price - user_balance:.0f} ‚≠êÔ∏è\n\n'
            f'üí° –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã',
            parse_mode="HTML",
            reply_markup=bt.balance_menu()
        )
        await callback.answer("‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤", show_alert=True)
        return

    # Balans yetarli - state o'rnatish (pul hali yechilmaydi!)
    if callback.data in ['not', 'again_gpt3']:
        await callback.message.answer(
            f'ü§ñ <b>GPT-3.5 –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω</b>\n\n'
            f'üí¨ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å\n'
            f'üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: {price} ‚≠êÔ∏è\n'
            f'üìä –í–∞—à –±–∞–ª–∞–Ω—Å: {user_balance:.0f} ‚≠êÔ∏è',
            parse_mode="HTML"
        )
        await state.set_state(AiState.gpt3)
        await state.update_data(context=False)

    elif callback.data == 'with':
        await callback.message.answer(
            f'ü§ñ <b>GPT-3.5 —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω</b>\n\n'
            f'üí¨ –ù–∞—á–Ω–∏—Ç–µ –¥–∏–∞–ª–æ–≥\n'
            f'üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ: {price} ‚≠êÔ∏è\n'
            f'üìä –í–∞—à –±–∞–ª–∞–Ω—Å: {user_balance:.0f} ‚≠êÔ∏è\n\n'
            f'‚ÑπÔ∏è –î–ª—è –≤—ã—Ö–æ–¥–∞: /start –∏–ª–∏ /reset',
            parse_mode="HTML"
        )
        await state.set_state(AiState.gpt3)
        await state.update_data(context=True)

    elif callback.data in ['not4', 'again_gpt4']:
        await callback.message.answer(
            f'ü§ñ <b>GPT-4 –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω</b>\n\n'
            f'üí¨ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à –≤–æ–ø—Ä–æ—Å\n'
            f'üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å: {price} ‚≠êÔ∏è\n'
            f'üìä –í–∞—à –±–∞–ª–∞–Ω—Å: {user_balance:.0f} ‚≠êÔ∏è',
            parse_mode="HTML"
        )
        await state.set_state(AiState.gpt4)
        await state.update_data(context=False)

    elif callback.data == 'with4':
        await callback.message.answer(
            f'ü§ñ <b>GPT-4 —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω</b>\n\n'
            f'üí¨ –ù–∞—á–Ω–∏—Ç–µ –¥–∏–∞–ª–æ–≥\n'
            f'üí∞ –°—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ: {price} ‚≠êÔ∏è\n'
            f'üìä –í–∞—à –±–∞–ª–∞–Ω—Å: {user_balance:.0f} ‚≠êÔ∏è\n\n'
            f'‚ÑπÔ∏è –î–ª—è –≤—ã—Ö–æ–¥–∞: /start –∏–ª–∏ /reset',
            parse_mode="HTML"
        )
        await state.set_state(AiState.gpt4)
        await state.update_data(context=True)

    await callback.answer()


@client_bot_router.callback_query(F.data.in_({"back", "back_on_menu"}))
async def back_callback(callback: types.CallbackQuery, state: FSMContext, bot: Bot):
    user_id = callback.from_user.id
    if callback.data == 'back':
        try:
            result = await get_user_balance_db(user_id, bot.token)
            print(result)
            await callback.message.edit_text(f'–ü—Ä–∏–≤–µ—Ç {callback.from_user.username}\n–í–∞—à –±–∞–ª–∞–Ω—Å - {result:.0f}',
                                             reply_markup=bt.first_buttons())
            await state.clear()
        except Exception as e:
            print(e)
            await start_message(callback.message, bot)
    elif callback.data == 'back_on_menu':
        try:
            await callback.message.edit_text(
                f'–ü—Ä–∏–≤–µ—Ç {callback.from_user.first_name}',
                reply_markup=bt.first_buttons()
            )
            await state.clear()
        except Exception as e:
            await callback.message.edit_text(
                f'–ü—Ä–∏–≤–µ—Ç {callback.from_user.first_name}',
                reply_markup=bt.first_buttons()
            )
            print(e)


@client_bot_router.callback_query(F.data.in_({"alloy", "echo", "nova", "fable", "shimmer"}))
async def voice_selection_callback(callback: types.CallbackQuery, state: FSMContext):
    user_id = callback.from_user.id
    user_balance = await get_user_balance_db(user_id)
    if user_balance >= 3:
        await update_balance(tg_id=user_id, sign='-', amount=3)
        await callback.message.edit_text("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –æ–∑–≤—É—á–∫–∏:")
        await state.set_data({"voice": callback.data})
        await state.set_state('waiting_for_text_to_voice')
    else:
        await callback.message.answer('–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –Ω–∞ –±–∞–ª–∞–Ω—Å–µ —Ç—ã–∫–∞–π --> /start')


@client_bot_router.callback_query(F.data == "settings")
async def settings_callback(callback: types.CallbackQuery):
    await callback.message.edit_text('–ù–∞—Å—Ç—Ä–æ–π–∫–∏', reply_markup=bt.settings())


@client_bot_router.callback_query(F.data == "helper")
async def helper_callback(callback: types.CallbackQuery):
    await callback.message.edit_text('‚ÑπÔ∏è –ü–æ–º–æ—â—å:', reply_markup=bt.help_bt())


@client_bot_router.callback_query(F.data == "FAQ")
async def faq_callback(callback: types.CallbackQuery):
    await callback.message.edit_text('‚ùî –ß–∞—Å—Ç–æ –∑–∞–¥–∞–≤–∞–µ–º—ã–µ –≤–æ–ø—Ä–æ—Å—ã', reply_markup=bt.faqs())


@client_bot_router.callback_query(F.data == "what")
async def what_bot_can_do_callback(callback: types.CallbackQuery):
    await callback.message.edit_text(
        'ü§ñ –ß—Ç–æ —É–º–µ–µ—Ç –±–æ—Ç?\n\n'
        '–ë–æ—Ç —É–º–µ–µ—Ç –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ –ª—é–±—ã–µ –≤–æ–ø—Ä–æ—Å—ã (GPT-4 Turbo), –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å '
        '–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (DALL¬∑E 3), –æ–∑–≤—É—á–∏–≤–∞—Ç—å —Ç–µ–∫—Å—Ç (TTS), '
        '–ø—Ä–µ–≤—Ä–∞—â–∞—Ç—å –∞—É–¥–∏–æ –≤ —Ç–µ–∫—Å—Ç (Whisper) –∏ –º–Ω–æ–≥–æ–µ –¥—Ä—É–≥–æ–µ.',
        reply_markup=bt.back_in_faq()
    )


@client_bot_router.callback_query(F.data == "use")
async def how_to_use_callback(callback: types.CallbackQuery):
    await callback.message.edit_text(
        'üìñ –ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –±–æ—Ç–∞?\n\n'
        '–ü—Ä–æ—Å—Ç–æ –≤—ã–±–µ—Ä–∏—Ç–µ –Ω—É–∂–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –∏–∑ –º–µ–Ω—é –∏ —Å–ª–µ–¥—É–π—Ç–µ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—è–º. '
        '–î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –æ–ø–∏—à–∏—Ç–µ, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ —É–≤–∏–¥–µ—Ç—å. '
        '–î–ª—è –æ–∑–≤—É—á–∫–∏ —Ç–µ–∫—Å—Ç–∞ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π —Ö–æ—Ç–∏—Ç–µ –æ–∑–≤—É—á–∏—Ç—å. '
        '–î–ª—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏ –∞—É–¥–∏–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –∞—É–¥–∏–æ—Ñ–∞–π–ª.',
        reply_markup=bt.back_in_faq()
    )


@client_bot_router.callback_query(F.data == "balance")
async def what_is_balance_callback(callback: types.CallbackQuery):
    await callback.message.edit_text(
        'üí∞ –ß—Ç–æ —Ç–∞–∫–æ–µ –±–∞–ª–∞–Ω—Å?\n\n'
        '–ë–∞–ª–∞–Ω—Å ‚Äî —ç—Ç–æ –≤–∞—à–∏ —Å—Ä–µ–¥—Å—Ç–≤–∞, –∫–æ—Ç–æ—Ä—ã–µ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è –æ–ø–ª–∞—Ç—ã –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –±–æ—Ç—É. '
        '–ö–∞–∂–¥—ã–π –∑–∞–ø—Ä–æ—Å –∫ GPT, –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–ª–∏ –æ–∑–≤—É—á–∫–∞ —Ç–µ–∫—Å—Ç–∞ —Å—Ç–æ–∏—Ç –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä—É–±–ª–µ–π. '
        '–ë–∞–ª–∞–Ω—Å –º–æ–∂–Ω–æ –ø–æ–ø–æ–ª–Ω–∏—Ç—å —á–µ—Ä–µ–∑ –ø–ª–∞—Ç–µ–∂–Ω—É—é —Å–∏—Å—Ç–µ–º—É.',
        reply_markup=bt.back_in_faq()
    )


@client_bot_router.callback_query(F.data == "functions")
async def what_functions_callback(callback: types.CallbackQuery):
    await callback.message.edit_text(
        'üîß –ö–∞–∫–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–æ—Å—Ç—É–ø–Ω—ã?\n\n'
        '–î–æ—Å—Ç—É–ø–Ω—ã —Å–ª–µ–¥—É—é—â–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏:\n'
        '‚Ä¢ GPT-3.5 –∏ GPT-4 –¥–ª—è –æ—Ç–≤–µ—Ç–æ–≤ –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã\n'
        '‚Ä¢ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (DALL¬∑E 3)\n'
        '‚Ä¢ –û–∑–≤—É—á–∫–∞ —Ç–µ–∫—Å—Ç–∞ (TTS)\n'
        '‚Ä¢ –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ –∞—É–¥–∏–æ (Whisper)\n'
        '‚Ä¢ –ò –¥—Ä—É–≥–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã –¥–ª—è –µ–≥–æ —Ä–∞–±–æ—Ç—ã.',
        reply_markup=bt.back_in_faq()
    )


@client_bot_router.callback_query(F.data == "how")
async def how_to_pay_callback(callback: types.CallbackQuery):
    await callback.message.edit_text(
        'üí≥ –ö–∞–∫ –ø–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å?\n\n'
        '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è',
        reply_markup=bt.back_in_faq()
    )


# ==========================================
# GPT-3.5 HANDLER - YANGILANGAN
# ==========================================
@client_bot_router.message(AiState.gpt3, ChatGptFilter())
async def gpt3(message: Message, state: FSMContext):
    """GPT-3.5 handler with balance checking"""

    context_data = await state.get_data()
    context = context_data.get("context", False)

    user_id = message.from_user.id
    bot_db_id = await get_chatgpt_bot_db_id(message.bot.token)

    if not bot_db_id:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –±–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö")
        await state.clear()
        return

    # Context mode da reset komandalarini tekshirish
    if context and message.text in ['/start', '/restart', '/reset']:
        await state.clear()
        await start_message(message, state, message.bot)
        return

    if not message.text:
        await message.answer('–Ø –º–æ–≥—É –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç ! /start')
        return

    # Stars narxini aniqlash
    star_cost = STAR_PRICES['gpt3_context'] if context else STAR_PRICES['gpt3_no_context']

    try:
        # 1. BALANSNI TEKSHIRISH
        current_balance = await get_user_balance_db(user_id, bot_db_id)

        if current_balance < star_cost:
            await message.answer(
                f"‚ö†Ô∏è <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!</b>\n\n"
                f"üí∞ –í–∞—à –±–∞–ª–∞–Ω—Å: {current_balance:.0f} ‚≠êÔ∏è\n"
                f"üí≥ –¢—Ä–µ–±—É–µ—Ç—Å—è: {star_cost} ‚≠êÔ∏è\n"
                f"üìä –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç: {star_cost - current_balance:.0f} ‚≠êÔ∏è\n\n"
                f"üí° –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã",
                parse_mode="HTML",
                reply_markup=bt.balance_menu()
            )

            if not context:
                await state.clear()
            return

        # 2. BALANSDAN YECHIB OLISH
        success = await update_bc(tg_id=user_id, sign='-', amount=star_cost, bot_id=bot_db_id)

        if not success:
            await message.answer('‚ùå –û—à–∏–±–∫–∞ —Å–ø–∏—Å–∞–Ω–∏—è —Å—Ä–µ–¥—Å—Ç–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start')
            if not context:
                await state.clear()
            return

        new_balance = current_balance - star_cost

        # 3. GPT SO'ROVINI BAJARISH
        await message.bot.send_chat_action(message.chat.id, 'typing')

        logger.info(f'GPT3 {"CONTEXT" if context else "NO_CONTEXT"} user_id={user_id}, stars_deducted={star_cost}')

        gpt_answer = robot.chat_gpt(
            user_id=user_id,
            message=message.text,
            gpt='gpt-3.5-turbo',
            context=context
        )

        if gpt_answer:
            # Javobni yuborish + balans ma'lumoti
            balance_info = f"\n\nüí∞ –°–ø–∏—Å–∞–Ω–æ: {star_cost} ‚≠êÔ∏è | –û—Å—Ç–∞—Ç–æ–∫: {new_balance:.0f} ‚≠êÔ∏è"

            if not context:
                await message.answer(
                    gpt_answer + balance_info,
                    parse_mode='Markdown',
                    reply_markup=bt.again_gpt3()
                )
                await state.clear()
            else:
                await message.answer(
                    gpt_answer + balance_info,
                    parse_mode='Markdown'
                )
        else:
            # Xatolik - pul qaytariladi
            await update_bc(tg_id=user_id, sign='+', amount=star_cost, bot_id=bot_db_id)
            await message.answer('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞. –°—Ä–µ–¥—Å—Ç–≤–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã.')

            if not context:
                await state.clear()

    except Exception as e:
        logger.error(f'GPT3 Error: {e}', exc_info=True)

        # Xatolik bo'lsa, pul qaytariladi
        try:
            await update_bc(tg_id=user_id, sign='+', amount=star_cost, bot_id=bot_db_id)
            await message.answer('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞. –°—Ä–µ–¥—Å—Ç–≤–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã.')
        except:
            await message.answer('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞')

        if not context:
            await state.clear()


# ==========================================
# GPT-4 HANDLER - YANGILANGAN
# ==========================================
@client_bot_router.message(AiState.gpt4, ChatGptFilter())
async def gpt4(message: Message, state: FSMContext):
    """GPT-4 handler with balance checking"""

    context_data = await state.get_data()
    context = context_data.get("context", False)

    user_id = message.from_user.id
    bot_db_id = await get_chatgpt_bot_db_id(message.bot.token)

    if not bot_db_id:
        await message.answer("‚ùå –û—à–∏–±–∫–∞: –±–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö")
        await state.clear()
        return

    # Context mode da reset komandalarini tekshirish
    if context and message.text in ['/start', '/restart', '/reset']:
        await state.clear()
        await start_message(message, state, message.bot)
        return

    if not message.text:
        await message.answer('–Ø –º–æ–≥—É –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ç–µ–∫—Å—Ç ! /start')
        return

    # Stars narxini aniqlash
    star_cost = STAR_PRICES['gpt4_context'] if context else STAR_PRICES['gpt4_no_context']

    try:
        # 1. BALANSNI TEKSHIRISH
        current_balance = await get_user_balance_db(user_id, bot_db_id)

        if current_balance < star_cost:
            await message.answer(
                f"‚ö†Ô∏è <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤!</b>\n\n"
                f"üí∞ –í–∞—à –±–∞–ª–∞–Ω—Å: {current_balance:.0f} ‚≠êÔ∏è\n"
                f"üí≥ –¢—Ä–µ–±—É–µ—Ç—Å—è: {star_cost} ‚≠êÔ∏è\n"
                f"üìä –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç: {star_cost - current_balance:.0f} ‚≠êÔ∏è\n\n"
                f"üí° –ü–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è —Ä–∞–±–æ—Ç—ã",
                parse_mode="HTML",
                reply_markup=bt.balance_menu()
            )

            if not context:
                await state.clear()
            return

        # 2. BALANSDAN YECHIB OLISH
        success = await update_bc(tg_id=user_id, sign='-', amount=star_cost, bot_id=bot_db_id)

        if not success:
            await message.answer('‚ùå –û—à–∏–±–∫–∞ —Å–ø–∏—Å–∞–Ω–∏—è —Å—Ä–µ–¥—Å—Ç–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ /start')
            if not context:
                await state.clear()
            return

        new_balance = current_balance - star_cost

        # 3. GPT SO'ROVINI BAJARISH
        await message.bot.send_chat_action(message.chat.id, 'typing')

        logger.info(f'GPT4 {"CONTEXT" if context else "NO_CONTEXT"} user_id={user_id}, stars_deducted={star_cost}')

        gpt_answer = robot.chat_gpt(
            user_id=user_id,
            message=message.text,
            gpt="gpt-4o",
            context=context
        )

        if gpt_answer:
            # Javobni yuborish + balans ma'lumoti
            balance_info = f"\n\nüí∞ –°–ø–∏—Å–∞–Ω–æ: {star_cost} ‚≠êÔ∏è | –û—Å—Ç–∞—Ç–æ–∫: {new_balance:.0f} ‚≠êÔ∏è"

            if not context:
                await message.answer(
                    gpt_answer + balance_info,
                    parse_mode='Markdown',
                    reply_markup=bt.again_gpt4()
                )
                await state.clear()
            else:
                await message.answer(
                    gpt_answer + balance_info,
                    parse_mode='Markdown'
                )
        else:
            # Xatolik - pul qaytariladi
            await update_bc(tg_id=user_id, sign='+', amount=star_cost, bot_id=bot_db_id)
            await message.answer('‚ùå GPT4 –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω. –°—Ä–µ–¥—Å—Ç–≤–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã.')

            if not context:
                await state.clear()

    except Exception as e:
        logger.error(f'GPT4 Error: {e}', exc_info=True)

        # Xatolik bo'lsa, pul qaytariladi
        try:
            await update_bc(tg_id=user_id, sign='+', amount=star_cost, bot_id=bot_db_id)
            await message.answer('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞. –°—Ä–µ–¥—Å—Ç–≤–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω—ã.')
        except:
            await message.answer('‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞')

        if not context:
            await state.clear()


# ==========================================
# BALANCE & PAYMENT HANDLERS
# ==========================================

@client_bot_router.callback_query(F.data == "ref",ChatGptFilter())
async def gain(message: Message, bot: Bot, state: FSMContext):
    bot_db = await shortcuts.get_bot(bot)
    await state.clear()
    if shortcuts.have_one_module(bot_db, 'chatgpt'):
        channels_checker = await check_channels(message)
        checker_banned = await banned(message)
        if channels_checker and checker_banned:
            me = await bot.get_me()
            link = f"https://t.me/{me.username}?start={message.from_user.id}"

            price = await get_actual_price(bot.token)

            await message.bot.send_message(message.from_user.id,
                                           f"üë• –ü—Ä–∏–≥–ª–∞—à–∞–π –¥—Ä—É–∑–µ–π –∏ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π, –∑–∞ \n–∫–∞–∂–¥–æ–≥–æ –¥—Ä—É–≥–∞ —Ç—ã –ø–æ–ª—É—á–∏—à—å {price}‚ÇΩ\n\n"
                                           f"üîó –í–∞—à–∞ —Å—Å—ã–ª–∫–∞ –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π:\n {link}",
                                           reply_markup=await main_menu_bt())
    else:
        channels_checker = await check_channels(message)
        checker_banned = await banned(message)
        if channels_checker and checker_banned:
            me = await bot.get_me()
            link = f"https://t.me/{me.username}?start={message.from_user.id}"

            price = await get_actual_price(bot.token)

            await message.bot.send_message(message.from_user.id,
                                           f"üë• –ü—Ä–∏–≥–ª–∞—à–∞–π –¥—Ä—É–∑–µ–π –∏ –∑–∞—Ä–∞–±–∞—Ç—ã–≤–∞–π, –∑–∞ \n–∫–∞–∂–¥–æ–≥–æ –¥—Ä—É–≥–∞ —Ç—ã –ø–æ–ª—É—á–∏—à—å {price}‚ÇΩ\n\n"
                                           f"üîó –í–∞—à–∞ —Å—Å—ã–ª–∫–∞ –¥–ª—è –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π:\n {link}"
                                           "\n –ß—Ç–æ –±—ã –≤–µ—Ä–Ω—É—Ç—å —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –±–æ—Ç–∞ –Ω–∞–ø–∏—à–∏—Ç–µ /start",
                                           reply_markup=await main_menu_bt())

@client_bot_router.callback_query(F.data == "show_balance")
async def show_balance_callback(callback: types.CallbackQuery):
    """Balansni ko'rsatish - faqat Stars"""
    user_id = callback.from_user.id

    bot_db_id = await get_chatgpt_bot_db_id(callback.bot.token)

    if not bot_db_id:
        await callback.answer("‚ùå –û—à–∏–±–∫–∞: –±–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö", show_alert=True)
        return

    try:
        user_balance = await get_user_balance_db(user_id, bot_db_id)

        await callback.message.edit_text(
            f"üí∞ <b>–í–∞—à –±–∞–ª–∞–Ω—Å:</b> {user_balance:.0f} ‚≠êÔ∏è\n\n"
            f"üìä <b>–¢–∞—Ä–∏—Ñ—ã:</b>\n"
            f"‚Ä¢ GPT-3.5 –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞: 1 ‚≠êÔ∏è\n"
            f"‚Ä¢ GPT-3.5 —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º: 2 ‚≠êÔ∏è\n"
            f"‚Ä¢ GPT-4 –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞: 3 ‚≠êÔ∏è\n"
            f"‚Ä¢ GPT-4 —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º: 4 ‚≠êÔ∏è\n\n"
            f"üí° –ü–æ–ø–æ–ª–Ω–∏—Ç—å –±–∞–ª–∞–Ω—Å –º–æ–∂–Ω–æ —á–µ—Ä–µ–∑ –≥–ª–∞–≤–Ω—ã–π –±–æ—Ç",
            reply_markup=bt.balance_menu(),
            parse_mode="HTML"
        )
    except Exception as e:
        logger.error(f"Error showing balance: {e}")
        await callback.message.edit_text(
            "–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∞–ª–∞–Ω—Å–∞",
            reply_markup=bt.back()
        )

    await callback.answer()


@client_bot_router.callback_query(F.data == "top_up_balance")
async def top_up_balance_callback(callback: types.CallbackQuery):
    await callback.message.edit_text(
        "üí≥ <b>–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ Stars –¥–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è:</b>\n\n"
        "‚≠êÔ∏è <i>–û–ø–ª–∞—Ç–∞ —á–µ—Ä–µ–∑ Telegram Stars</i>\n"
        "üîí <i>–ë–µ–∑–æ–ø–∞—Å–Ω–æ –∏ –º–≥–Ω–æ–≤–µ–Ω–Ω–æ</i>",
        reply_markup=bt.top_up_options(),
        parse_mode="HTML"
    )
    await callback.answer()


@client_bot_router.callback_query(F.data.startswith("topup_"))
async def topup_redirect_callback(callback: types.CallbackQuery):
    """Stars orqali to'lov - faqat Stars ko'rsatish"""
    stars_amount = callback.data.replace("topup_", "").replace("_star", "").replace("_stars", "")
    main_bot_username = "konstruktor_test_my_bot"

    bot_db_id = await get_chatgpt_bot_db_id(callback.bot.token)

    if not bot_db_id:
        await callback.answer("‚ùå –û—à–∏–±–∫–∞: –±–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö", show_alert=True)
        logger.error(f"Bot DB ID not found for token: {callback.bot.token[:10]}...")
        return

    logger.info(f"User {callback.from_user.id} redirecting to payment: {stars_amount} stars, bot_db_id={bot_db_id}")

    await callback.message.edit_text(
        f"üíé <b>–ü–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –Ω–∞ {stars_amount} Stars</b>\n\n"
        f"üîÑ –ü–µ—Ä–µ—Ö–æ–¥–∏—Ç–µ –≤ –æ—Å–Ω–æ–≤–Ω–æ–π –±–æ—Ç –¥–ª—è –æ–ø–ª–∞—Ç—ã:\n"
        f"üëá –ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ",
        reply_markup=InlineKeyboardBuilder().button(
            text=f"üí≥ –ü–µ—Ä–µ–π—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ ({stars_amount} ‚≠êÔ∏è)",
            url=f"https://t.me/{main_bot_username}?start=gptbot_{callback.from_user.id}_{stars_amount}_{bot_db_id}"
        ).as_markup(),
        parse_mode="HTML"
    )

    await callback.answer("üîÑ –ü–µ—Ä–µ—Ö–æ–¥–∏—Ç–µ –≤ –æ—Å–Ω–æ–≤–Ω–æ–π –±–æ—Ç –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ–ø–ª–∞—Ç—ã")